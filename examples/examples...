

------------------------------------------------------------------------
-- 
-- BASIC FUNCTIONS
-- 
------------------------------------------------------------------------

catelli [x1, ..., xn] [y1, ..., ym] = [x1, ..., xn, y1, ..., ym]

headelli [x1, ..., xn] = x1

lastelli [x1, ..., xn] = xn

tailelli [x1, ..., xn] = [x2, ..., xn]

initelli [x1, ..., xn] = [x1, ..., x{n-1}]

-- (Using errors instead of maybes)

uncons xs = case xs of {
    []              -> error;
    [x1, ..., xn]   -> (x1, [x2, ..., xn]);
}

unsnoc xs = case xs of {
    []              -> error;
    [x1, ..., xn]   -> ([x1, ..., x{n-1}], xn);
}

singleton x = [x]

null xs = xs == []

lengthelli [x1, ..., xn] = n

------------------------------------------------------------------------
-- 
-- LIST TRANSFORMATIONS
-- 
------------------------------------------------------------------------

mapelli f [x1, ..., xn] = [f x1, ..., f xn]

reverseelli [x1, ..., xn] = [xn, ..., x1]

intersperse c xs = case xs of {
    []              -> [];
    [x1, ..., xn]   -> [x1, c] ++ ... ++ [x{n-1}, c] ++ [xn];
}

-- intercalate

-- transpose

-- subsequences

-- permutations

------------------------------------------------------------------------
-- 
-- FOLDS
-- 
------------------------------------------------------------------------

foldlelli g z [x1, ..., xn] = z `g` x1 `g` ... `g` xn

foldl1elli g [x1, ..., xn] = x1 `g` ... `g` xn

foldrelli g z [x1, ..., xn] = x1 `g` (... `g` (xn `g` z))

foldr1elli g [x1, ..., xn] = x1 `g` (... `g` xn)


------------------------------------
-- Special folds
------------------------------------

concat [x1, ..., xn] = x1 ++ ... ++ xn ++ []

concatMap f [x1, ..., xn] = (f x1) ++ ... ++ (f xn) ++ []

and [x1, ..., xn] = x1 && ... && xn && True

or [x1, ..., xn] = x1 || ... || xn || False

any p [x1, ..., xn] = p x1 || ... || p xn || False

all p [x1, ..., xn] = p x1 && ... && p xn && True

sum [x1, ..., xn] = 0 + x1 + ... + xn

product [x1, ..., xn] = 1 * x1 * ... * xn

maximum [x1, ..., xn] = x1 `max` ... `max` xn

minimum [x1, ..., xn] = x1 `min` ... `min` xn

------------------------------------------------------------------------
--
-- BUILDING LISTS
--
------------------------------------------------------------------------

------------------------------------
-- scans
------------------------------------

{- scanl g z [x1, ..., xn]
    = [z, (z `g` x1), (z `g` x1 `g` x2), ..., (z `g` x1 `g` ... `g` xn)]
-}

scanl1 g [x1, ..., xn] = [x1, (x1 `g` x2), ..., (x1 `g` ... `g` xn)]

-- scanr g z [x1, ..., xn] = [(x1 `g` (... `g` (xn `g` z))), ..., (xn `g` z), z]

-- scanr1 g [x1, ..., xn] = [x1 `g` (... `g` xn), ..., xn]

------------------------------------
-- accumulating maps
------------------------------------

-- mapAccumL

-- mapAccumR

------------------------------------
-- infinite lists
------------------------------------

-- My language does not have infinite lists

insertAt y k [x1, ..., xn] = [x1, ..., x{k}, y, x{k+1}, ..., xn]


------------------------------------
-- unfolding
------------------------------------

-- My language does not have unfolding (but it would be cool)

------------------------------------------------------------------------
--
-- Sublists
--
------------------------------------------------------------------------

------------------------------------
-- Extracting sublists
------------------------------------

take k [x1, ..., xn] = [x1, ..., xk]

drop k [x1, ..., xn] = [xk, ..., xn]

splitAt k [x1, ..., xn] = ([x1, ..., xk], [x{k+1}, ..., xn])

-- takeWhile

-- dropWhile

-- dropWhileEnd

-- span

-- break

stripPrefix [p1, ..., pk] [x1, ..., xn] =
    if [p1, ..., pk] == [x1, ..., xk]
    then [x{k+1}, ..., xn]
    else error

-- group

group [x1, ..., xn] = []

-- groupBy

initselli [x1, ..., xn] = [ [], [x1], ..., [x1, ..., xn]]

-- tails [x1, ..., xn] = [ [x1, ..., xn], ..., [] ]

------------------------------------------------------------------------
--
-- PREDICATES
-- 
------------------------------------------------------------------------

isPrefixOf [p1, ..., pk] [x1, ..., xn] = [p1, ..., pk] == [x1, ..., xk]

isSuffixOf [s1, ..., sk] [x1, ..., xn] = [s1, ..., sk] == [x{n-k+1}, ..., xn]

isInfixOf [i1, ..., ik] [x1, ..., xn]
    = ([i1, ..., ik] == [x1, ..., xk]) || ... || ([i1, ..., ik] == [x{n-k+1}, ..., xn]) || False

oror a b = a || b

isInfixOf2 [i1, ..., ik] [x1, ..., xn] = foldr oror False (
    from [i1, ..., ik] == [x1, ..., xk]
    to   [i1, ..., ik] == [x{n-k+1}, ..., xn])

-- isSubsequenceOf

------------------------------------------------------------------------
--
-- SEARCHING LISTS
-- 
------------------------------------------------------------------------

------------------------------------
-- searching by equality
------------------------------------

elem y [x1, ..., xn] = (y == x1) || ... || (y == xn) || False

notElem y [x1, ..., xn] = (y /= x1) && ... && (y /= xn) && True

{- Needs better patterns
lookup yk [(k1, v1), ..., (kn, vn)] = 
    case elemIndex1 yk [k1, ..., kn] of
        Just i  -> Just vi
        Nothing -> Nothing
-}

------------------------------------
-- searching with a predicate
------------------------------------

-- find

myfilter p [x1, ..., xn] 
    = (if p x1 then [x1] else []) ++ ... ++ (if p xn then [xn] else []) ++ []

myfilter2 p [x1, ..., xn] = foldr cat [] $
    from if p x1 then [x1] else []
    to   if p xn then [xn] else []


{- ditto
partition p [x1, ..., xn] = ([x1, ..., xn | p x], [x1, ..., xn | not (p x)])
-}

------------------------------------------------------------------------
--
-- INDEXING LISTS
-- 
------------------------------------------------------------------------

subscript1 [x1, ..., xn] k = xk

subscript [x1, ..., xn] k = x{k+1}

elemIndices1 y [x1, ..., xn]
    = [if y == x1 then [1] else []] ++ ... ++ [if y == xn then [n] else []] ++ []

elemIndices2 y [x1, ..., xn] = foldr cat [] $
    from if y == x1 then [1] else []
    to   if y == xn then [n] else []

findIndices1 p [x1, ..., xn] = [if p x1 then [1] else []] ++ ... ++ [if p xn then [n] else []]

findIndices2 p [x1, ..., xn] = foldr cat [] $
    from if p x1 then [1] else []
    to   if p xn then [n] else []



------------------------------------------------------------------------
--
-- ZIPPING AND UNZIPPING LISTS
-- 
------------------------------------------------------------------------

zip [x1, ..., xn] [y1, ..., ym] = [(x1, y1), ..., (xn, ym)]

-- ...

zipWith f [x1, ..., xn] [y1, ..., ym] = [f x1 y1, ..., f xn ym]

-- ...

-- unzip

-- ...

------------------------------------------------------------------------
--
-- "SET" OPERATIONS
--
------------------------------------------------------------------------

nub [x1, ..., xn] = foldr cat [] (
    from if x1 `elem` []                then [] else [x1]
    to   if xn `elem` [x1, ..., x{n-1}] then [] else [xn])

{- delete y [x1, ..., xn] = case k = findIndices1 y [x1, ..., xn] of {
    k:xs    -> [x1, ..., x{k-1}, x{k+1}, ..., xn];
    []      -> [x1, ..., xn];
} -}
    
-- \\

-- union

-- intersect

------------------------------------------------------------------------
-- 
-- ORDERED LISTS
-- 
------------------------------------------------------------------------

-- sort

-- sortOn

-- insert



------------------------------------------------------------------------
--
-- OTHERS FROM EXAMPLES.TXT
--
------------------------------------------------------------------------

-- Success: map, fold, fac, cat, reverse, zip, zipWith, take, drop, 
-- splitAt mapR, foldm, foldz, dotProduct, concatMap, intersperse, 
-- all, and, rdup (see nub)

-- Failed: insert, lookup, takeWhile, dropWhile, groupBy

{- rdup would also need more advanced list patterns
rdup [x1, ..., y, ..., y, ..., xn] = [x1, ..., y, ..., xn]
-}

fac n = n * ... * 1

mapR f [x1, ..., xn] = [f xn, ..., f x1]

foldm g f [x1, ..., xn] = (f x1) `g` ... `g` (f xn)

foldz g [x1, ..., xn] [y1, ..., ym]
    = (x1, y1) `g` ... `g` (xn, ym)

dotProduct [x1, ..., xn] [y1, ..., ym]
    = if n == m
      then 0 + x1*y1 + ... + xn*yn
      else error

------------------------------------------------------------------------
--
-- OTHERS
--
------------------------------------------------------------------------

neighbors [x1, ..., xn] = [(x1, x2), ..., (x{n-1}, xn)]

remove k [x1, ..., xn] = [x1, ..., x{k-1}, x{k+1}, ..., xn]

replace k y [x1, ..., xn] = [x1, ..., x{k-1}, y, x{k+1}, ..., xn]

rotL k [x1, ..., xn] =
    let kMod = k `mod` n
    in [x{kMod + 1}, ..., xn, x1, ..., x{kMod}]

combinations [x1, ..., xn] [y1, ..., ym] 
    = [(x1, y1), ..., (xn, y1)] ++ ... ++ [(x1, ym), ..., (xn, ym)] ++ []


count e [x1, ..., xn] = 0 + (if x1 == e then 1 else 0) + ... + (if xn == e then 1 else 0)

sublistOccurs [y1, ..., yk] [x1, ..., xn] = count True (
    from [y1, ..., yk] == [x1, ..., xk]
    to   [y1, ..., yk] == [x{n-k+1}, ..., xn])

isEven x = (x `mod` 2) == 0

isOdd x = (x `mod` 2) == 1