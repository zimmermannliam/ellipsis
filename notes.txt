Evaluate: does it make sense to use them on the left hand, right hand in examples?
Pretty printer
map, fold, reverse, second, length, nth, zip, find
implement in my language, then how would we define it in
Don't just store the lenght, then we w would be calculating the length for nothing if it was a small access
Has to be somethign more compliacted than (name,val) in environment -- 
Don't do more than necessary computationally
Write notes to inform thesis -- this step right now is important!

ex: Creating our langauge, what would ellipsis patterns look like, how would we implmenet them, define operational semantics, argue or improve semantics, evaluate expressiveness

Look at library, how many can we implement, how much shorter, and cool cases (or uncool cases), matrices, 

------------------------------------------------------------------------

True design decisions:
Should yi ... yj i > j count backwards? Yes
Should we keep a 







What is ellipsis?

On the LHS, we have:
y1 ... yn -> <something>
Which just specifies the name of the list (y) and the length (n)

On the RHS, we have
y1 ... yn -> <something> yi ... yj <something>
or                     f yi ... f yj
or?                    yi `f` ... `f` yj




Lost my computer

What are the things I need to think of?



What is allowed?
y1 ... yn   -> yi
y1 ... yn   -> y1 ... y3
y1 ... yn   -> yn-5 ... yn
y1 ... yn   -> yi ... yj
f, y1 ... yn   -> f y1 ... f yn
g, y1 ... yn   -> y1 `g` ... `g` yn
f, y1 ... yn   -> y1 (f y2) ... (f yn-1) yn

What is not allowed?

g, y1 ... yn -> y1 `g` y2 y3 `g` y4 ... yn-1 `g` yn
any sort of inductive pattern-establishing system
(i.e. x1 x3 x5 ... xn-5 xn-3 xn-1) would just be:
      x1 x3 x5 x6 x7 x8 ... xn-7 xn-6 xn-5 xn-3 xn-1)

Ambiguous
f, y1 ... yn    -> f y1 ... yn
    It would have to be either
    f y1 y2 ... yn
    or 
    f y1 ... f yn-1 yn
    So any operation on the ellipsis has to be applied to both sides.

y1 ... yn -> yn ... y1
    The ellipsis must count up?
    OR does yi ... yj, i > j mean count backwards?





identity l:
case l of
    y1 ... yn   -> y1 ... yn

map f l:
case l of
    y1 ... yn   -> f y1 ... f yn

head l:
case l of
    y1 ... yn   -> y1

tail l:
case l of
    y1 ... yn   -> y2 ... yn

at l i
case l of
    y1 ... yn   -> yi

insert l i k
case l of
    y1 ... yn   -> y1 ... yi k yi+1 ... yn










pg 72



{-
f (l) = case l of 
        x:xs -> x + 1
        []   -> 0
pattern matching adds bindings to the environment according ot the pattern

evaluate
???
add bindings to environment
-}


{-
plusfive = Abstr "x" $ Add (Var "x") (Value $ Con 5)


plus = Abstr "x" $ Abstr "y" $ Add (Var "x") (Var "y")

stz' = (Abstr "x" $ 
         Case (Var "x") 
             (Con 0)     (Value $ Con 0) 
                         (Add (Var "x") (App (Var "stz") (Add (Var "x") (Value $ Con (-1)))))
       )

stz = LetRec "stz" stz'
-- eval [] $ stz (App (Var "stz") (Value $ Con 10))

len' = (Abstr "l" $
        Case (Var "l")
            Empty       (Value $ Con 0)
                        (Add (Value $ Con 1) (App (Var "len") (Tail (Var "l"))))
       )

len = LetRec "len" len'

pp :: Expr -> String
pp (Var vn)         = vn
pp (App e1 e2)      = "(" ++ (pp e1) ++ " " ++ (pp e2) ++ ")"
pp (Abstr vn e)     = "\\" ++ vn ++ "." ++ (pp e)

main :: IO ()
main = do
  putStrLn $ show $ eval [] $ 
                len (App (Var "len") (Value $ Cons 100 $ Cons 2 $ Cons 3 $ Cons 5 Empty))

pp (Value (Con i))  = show i
pp (Value Empty)    = ""
pp (Value (Cons i e)) = "[" ++ ppCons (Cons i e) ++ "]"
pp (Let vn e1 e2)   = "" -- "let " ++ vn ++ " = (" ++ (pp e1) ++ ") in " ++ (pp e2)
pp (Case vn c1 b1 b2) = "" -- "case " ++ vn ++ " of " ++ (pp c1) ++ " -> "
                        -- ++ (pp b1) ++ "; Otherwise -> " ++ (pp b2)
pp (Value (Fun n e)) = n ++ " " ++ (pp e)

ppCons :: Val -> String
ppCons (Cons i (Cons i2 e))     = show i ++ "," ++ ppCons (Cons i2 e)
ppCons (Cons i _)               = show i

bReduc :: Expr -> Expr
bReduc e = bReduc' e

-- Top level funciton, takes in Expr and outputs reduced expr
bReduc' :: Expr -> Expr
bReduc' (Var vn) = (Var vn)
bReduc' (Abstr vn e) = (Abstr vn (bReduc' e))
bReduc' (App e1 e2) = bApp (bReduc' e1) (bReduc' e2)
bReduc' e = e

-- Helper function for bReduc', for beta applications
bApp :: Expr -> Expr -> Expr
bApp (Abstr vn e1) e2 = let e2' = bReduc' e2 in
                            let e1' = replaceVar vn e2' e1 in
                                bReduc' e1'
bApp e1 e2 = App (bReduc' e1) (bReduc' e2)

-- Helper function for bReduc'.bApp, finds and replaces "needle" with "repl" in
-- "haystack".
--            needle     repl    haystack
replaceVar :: Name -> Expr -> Expr       -> Expr
replaceVar ndl repl (Var hstk) = if ndl == hstk then repl else Var hstk
replaceVar ndl repl (App hstk1 hstk2) = App (replaceVar ndl repl hstk1)
                                            (replaceVar ndl repl hstk2)
replaceVar ndl repl (Abstr hstk_vn hstk_e) = Abstr hstk_vn 
                                                   (replaceVar ndl repl hstk_e)

EXAMPLE I FAILED ON?

(\x.\y.(y x) (y w))         
homework answer:    \z.(z (y w))        
prog answer:        \y.(y (y w))
calculator answer:  with some finagling, \y0.y0 (y w), so y0 = z
hand answer:        \x.\y.(y x) (y w) -> 
"Avoid capturing the free variable y in (y w)"

Does this mean I need to take a first pass and replace any free variables?
-}





















meeting w8 (2023-03-7)
=================================================================================
Progress:
=================================================================================
Made letrec

=================================================================================
Pre-meeting notes and questions
=================================================================================

Where is this concept of "val" from? 
-> Various books
-> John Mitchell        Foundations of Programming Languages
-> 

Explore Fix:

f (Fix f) = Fix f

Y combinator does that ^

Don't have a great intuition regarding y combinator, but I think I understand
fix and fixed points and how it ties into my letrec



=================================================================================
Notes:
=================================================================================

to make pattern matching need to make pattern as a type

evaluate patterns against expressions to produce bindings
      or expressions against patterns

pattern could fail, not match, account for failure

we were starting with call by value

but peyton jones is call by name -- would get rid of values

=================================================================================
Deliverables:
=================================================================================
Read simon peyton jones -- Compiling of functional languages
make patterns -- follow peyton jones closely
ints bools and lists

add ellipsis as a pattern
and expressions






meeting w7 (2023-02-21)

=================================================================================
Progress:
=================================================================================

Only had 2 hours to work; started eval

=================================================================================
Q&A:
=================================================================================

fun vs abstr

apply fun with app?

=================================================================================
Notes:
=================================================================================

see operational semantics of app rule

-- case eval Expr of 
--  Val -> eval Expr
--  ow  -> eval Expr

-- try to impelment length
-- add let rec

-- applFun :: Env -> Val -> Expr -> Val
-- applFun e (Fun fn b) i = case (fn, i) of
--                           ("+", (App (Value $ Con i1))


=================================================================================
Deliverables:
=================================================================================

finish eval

do semantics in ellipsis




meeting w6 (2023-02-14)

=================================================================================
Progress:
=================================================================================

do map function in my abstract syntax:

let rec map = (\f.\l.case l of:
    Empty       -> Empty
    Otherwise   -> Cons (f (head l)) (map f (tail l)))



think about how that map function could be represented by our pattern language

We know:
map f:
x1, ..., xn -> f x1, ..., f xn

abstract syntax for pattern language -- start based on map --- look at all functions

See ellipsis.hs

=================================================================================
Q&A:
=================================================================================

Just where to go from here

=================================================================================
Notes:
=================================================================================

Let should be let rec

ellipsis.hs only really need one type of name

list of parameter name

synoynm for string

infinite application using same style as List Expl Expl or Cons (currying style)

Var String is all I really need

Position in list will have to be smart, a sublanguage

Semantics directly

Write interpreter? Write in lambda calculus?

Map or compile to fn'al langauge -- meaning in terms of an explanation

Pattern language simpler than lambda, less expressive, all pattern langauge can
go to lambda, but not all lambda can go to pattern language

lambda calculus:
don't replace expressions, too much
write a f'n Expr -> Value
Incldue operations on integers, +, binop
Val for values that

Function 
eval :: Env -> Expr -> Val

Env list of (name, value)

Expr has vals in it -- maybe just make vals a possiblitiy of expr

Nested constructors, smart constructors

A value is a pretty general thing



=================================================================================
Deliverables:
=================================================================================
implement eval (test)







meeting w4 (2023-01-31)

=================================================================================
Progress:
=================================================================================

Read types and PLs chapters 10, 11.5, 11.6, 11.9, 11.12
Implemented let, case, lists (and prettyprinted them)

=================================================================================
Q&A:
=================================================================================

What is |-> (see pg 124, not |- )
substitution

=================================================================================
Notes:
=================================================================================

let map = (



) in ABCABC

check f'n might be complicated -- offramp is find a semantics for the pattern
language 

Our ellipsis is DEFINED to be solid, not inductive

added syntactic sugar

very precise about our definition of ellipsis

pattern P

semantic f'n S : P -> D

langauge L

S' : L -> D

check : P * L -> B

Probably can't express general recursion

Saved by limited language


Semantics of pattern language

Then:

Check (p,l) => S(p) = S'(l)

Compile : P -> L

Explain : L -> P




=================================================================================
Deliverables:
=================================================================================
do map function in my abstract syntax
think about how that map function could be represented by our pattern language
abstract syntax for pattern language -- start based on map --- look at all functions\









meeting w3 (2023-01-24)

=================================================================================
Progress:
=================================================================================
Made lambda calculus
With beta reduction
Possibly erroneous

=================================================================================
Q&A:
=================================================================================
Current example "captures free variable y", is that ok? what do?

Test suite for lambda calculus? too trivial?

What feature to add to start out? Lists? Or are we doing the super lambdacalculusy list?

=================================================================================
Notes:
=================================================================================

Lists added

Abstract syntax for ellipsis

Pattern langauge, explanation langauge is the ellipsis langauge (Expl)

check :: Expr -> Expl -> Bool

Lambda calculus map, true matches explanation

add let expressions

let map f 

Case expression lambda calculus

Read types and programming langauges chapters 11.6, 11.9, let expressions, 

Play with case expressions

Case deconstructs and analyzes

extend lambda calculus syntax by lists, case, and let

do map fucntion in my abstract syntax

THEN

Think about an explanation langauge

THEN

think about check function

=================================================================================
Deliverables:
=================================================================================
